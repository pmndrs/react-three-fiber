//* Phase Graph - Dynamic Phase Management ==============================

import type { AddPhaseOptions } from '#types'

// Default phase order for the scheduler
const DEFAULT_PHASES = ['start', 'input', 'physics', 'update', 'render', 'finish'] as const

/**
 * PhaseGraph manages an ordered list of phases that can be extended at runtime.
 *
 * Default phases: start -> input -> physics -> update -> render -> finish
 *
 * Phases can be added dynamically:
 * - addPhase('clouds', { before: 'render' }) inserts 'clouds' before 'render'
 * - addPhase('postFx', { after: 'render' }) inserts 'postFx' after 'render'
 *
 * Auto-generated phases are created when jobs use before/after constraints
 * without an explicit phase (e.g., useFrameNext(cb, { before: 'render' }))
 */
export class PhaseGraph {
  /** Ordered list of phase nodes */
  private phases: PhaseNode[] = []

  /** Quick lookup by name */
  private phaseMap: Map<string, PhaseNode> = new Map()

  /** Cached ordered names (invalidated on changes) */
  private orderedNamesCache: string[] | null = null

  constructor() {
    this.initializeDefaultPhases()
  }

  //* Initialization --------------------------------

  private initializeDefaultPhases(): void {
    for (const name of DEFAULT_PHASES) {
      const node: PhaseNode = { name, isAutoGenerated: false }
      this.phases.push(node)
      this.phaseMap.set(name, node)
    }
    this.invalidateCache()
  }

  //* Public API --------------------------------

  /**
   * Add a named phase to the graph
   * @param name - Phase name (must be unique)
   * @param options - Position options (before or after another phase)
   */
  addPhase(name: string, options: AddPhaseOptions = {}): void {
    // Don't add duplicates
    if (this.phaseMap.has(name)) {
      console.warn(`[useFrame] Phase "${name}" already exists`)
      return
    }

    const { before, after } = options
    const node: PhaseNode = { name, isAutoGenerated: false }

    // Determine insertion index
    let insertIndex = this.phases.length // default: append at end

    const targetIndex = this.getPhaseIndex(before ?? after)
    if (targetIndex !== -1) insertIndex = before ? targetIndex : targetIndex + 1
    else {
      const constraintType = before ? 'before' : 'after'
      console.warn(`[useFrame] Phase "${before ?? after}" not found for '${constraintType}' constraint`)
    }

    // Insert at position
    this.phases.splice(insertIndex, 0, node)
    this.phaseMap.set(name, node)
    this.invalidateCache()
  }

  /**
   * Get ordered list of phase names
   */
  getOrderedPhases(): string[] {
    if (this.orderedNamesCache === null) this.orderedNamesCache = this.phases.map((p) => p.name)

    return this.orderedNamesCache
  }

  /**
   * Check if a phase exists
   */
  hasPhase(name: string): boolean {
    return this.phaseMap.has(name)
  }

  /**
   * Get the index of a phase (-1 if not found)
   */
  getPhaseIndex(name: string | undefined): number {
    if (!name) return -1
    return this.phases.findIndex((p) => p.name === name)
  }

  /**
   * Ensure a phase exists, creating an auto-generated one if needed.
   * Used for resolving before/after constraints.
   *
   * @param name - The phase name to ensure exists
   * @returns The phase name (may be auto-generated like 'before:render')
   */
  ensurePhase(name: string): string {
    if (this.phaseMap.has(name)) return name

    // Create auto-generated phase
    const node: PhaseNode = { name, isAutoGenerated: true }
    // Auto-generated phases go at the end by default
    this.phases.push(node)
    this.phaseMap.set(name, node)
    this.invalidateCache()

    return name
  }

  /**
   * Resolve where a job with before/after constraints should go.
   * Creates auto-generated phases if needed.
   *
   * @param before - Phase(s) to run before
   * @param after - Phase(s) to run after
   * @returns The resolved phase name
   */
  resolveConstraintPhase(before?: string | string[], after?: string | string[]): string {
    // Normalize to arrays and get first constraint as primary
    const beforeArr = before ? (Array.isArray(before) ? before : [before]) : []
    const afterArr = after ? (Array.isArray(after) ? after : [after]) : []

    // Handle before constraint
    if (beforeArr.length > 0) {
      return this.ensureAutoPhase(beforeArr[0], 'before', 0)
    }

    // Handle after constraint
    if (afterArr.length > 0) {
      return this.ensureAutoPhase(afterArr[0], 'after', 1)
    }

    // No constraints - default to 'update'
    return 'update'
  }

  /**
   * Ensure an auto-generated phase exists relative to a target phase.
   * Creates the phase if it doesn't exist, inserting it at the correct position.
   *
   * @param target - The target phase name to position relative to
   * @param prefix - Prefix for auto-generated phase name ('before' or 'after')
   * @param offset - Insertion offset (0 for before, 1 for after)
   * @returns The auto-generated phase name
   */
  private ensureAutoPhase(target: string, prefix: 'before' | 'after', offset: 0 | 1): string {
    const autoName = `${prefix}:${target}`

    // Return existing phase if it already exists
    if (this.phaseMap.has(autoName)) return autoName

    // Create auto-generated phase
    const node: PhaseNode = { name: autoName, isAutoGenerated: true }
    const targetIndex = this.getPhaseIndex(target)

    // Insert at target position + offset, or append if target doesn't exist
    if (targetIndex !== -1) this.phases.splice(targetIndex + offset, 0, node)
    else this.phases.push(node)

    this.phaseMap.set(autoName, node)
    this.invalidateCache()

    return autoName
  }

  // Internal --------------------------------

  private invalidateCache(): void {
    this.orderedNamesCache = null
  }
}

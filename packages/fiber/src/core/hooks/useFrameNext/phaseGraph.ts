//* Phase Graph - Dynamic Phase Management ==============================

import { DEFAULT_PHASES, type PhaseNode } from './types'
import type { AddPhaseOptions } from '#types'

/**
 * PhaseGraph manages an ordered list of phases that can be extended at runtime.
 *
 * Default phases: start -> input -> physics -> update -> render -> finish
 *
 * Phases can be added dynamically:
 * - addPhase('clouds', { before: 'render' }) inserts 'clouds' before 'render'
 * - addPhase('postFx', { after: 'render' }) inserts 'postFx' after 'render'
 *
 * Auto-generated phases are created when jobs use before/after constraints
 * without an explicit phase (e.g., useFrameNext(cb, { before: 'render' }))
 */
export class PhaseGraph {
  /** Ordered list of phase nodes */
  private phases: PhaseNode[] = []

  /** Quick lookup by name */
  private phaseMap: Map<string, PhaseNode> = new Map()

  /** Cached ordered names (invalidated on changes) */
  private orderedNamesCache: string[] | null = null

  constructor() {
    this.initializeDefaultPhases()
  }

  // Initialization --------------------------------

  private initializeDefaultPhases(): void {
    for (const name of DEFAULT_PHASES) {
      const node: PhaseNode = { name, isAutoGenerated: false }
      this.phases.push(node)
      this.phaseMap.set(name, node)
    }
    this.invalidateCache()
  }

  // Public API --------------------------------

  /**
   * Add a named phase to the graph
   * @param name - Phase name (must be unique)
   * @param options - Position options (before or after another phase)
   */
  addPhase(name: string, options: AddPhaseOptions = {}): void {
    // Don't add duplicates
    if (this.phaseMap.has(name)) {
      console.warn(`[useFrameNext] Phase "${name}" already exists`)
      return
    }

    const { before, after } = options
    const node: PhaseNode = { name, isAutoGenerated: false }

    // Determine insertion index
    let insertIndex = this.phases.length // default: append at end

    if (before) {
      const targetIndex = this.getPhaseIndex(before)
      if (targetIndex !== -1) {
        insertIndex = targetIndex
      } else {
        console.warn(`[useFrameNext] Phase "${before}" not found for 'before' constraint`)
      }
    } else if (after) {
      const targetIndex = this.getPhaseIndex(after)
      if (targetIndex !== -1) {
        insertIndex = targetIndex + 1
      } else {
        console.warn(`[useFrameNext] Phase "${after}" not found for 'after' constraint`)
      }
    }

    // Insert at position
    this.phases.splice(insertIndex, 0, node)
    this.phaseMap.set(name, node)
    this.invalidateCache()
  }

  /**
   * Get ordered list of phase names
   */
  getOrderedPhases(): string[] {
    if (this.orderedNamesCache === null) {
      this.orderedNamesCache = this.phases.map((p) => p.name)
    }
    return this.orderedNamesCache
  }

  /**
   * Check if a phase exists
   */
  hasPhase(name: string): boolean {
    return this.phaseMap.has(name)
  }

  /**
   * Get the index of a phase (-1 if not found)
   */
  getPhaseIndex(name: string): number {
    return this.phases.findIndex((p) => p.name === name)
  }

  /**
   * Ensure a phase exists, creating an auto-generated one if needed.
   * Used for resolving before/after constraints.
   *
   * @param name - The phase name to ensure exists
   * @returns The phase name (may be auto-generated like 'before:render')
   */
  ensurePhase(name: string): string {
    if (this.phaseMap.has(name)) return name

    // Create auto-generated phase
    const node: PhaseNode = { name, isAutoGenerated: true }
    // Auto-generated phases go at the end by default
    this.phases.push(node)
    this.phaseMap.set(name, node)
    this.invalidateCache()

    return name
  }

  /**
   * Resolve where a job with before/after constraints should go.
   * Creates auto-generated phases if needed.
   *
   * @param before - Phase(s) to run before
   * @param after - Phase(s) to run after
   * @returns The resolved phase name
   */
  resolveConstraintPhase(before?: string | string[], after?: string | string[]): string {
    // Normalize to arrays
    const beforeArr = before ? (Array.isArray(before) ? before : [before]) : []
    const afterArr = after ? (Array.isArray(after) ? after : [after]) : []

    // If before constraint, create/use a phase that comes before it
    if (beforeArr.length > 0) {
      const target = beforeArr[0] // Use first constraint as primary
      const autoName = `before:${target}`

      if (!this.phaseMap.has(autoName)) {
        // Create auto-generated phase before the target
        const node: PhaseNode = { name: autoName, isAutoGenerated: true }
        const targetIndex = this.getPhaseIndex(target)
        if (targetIndex !== -1) {
          this.phases.splice(targetIndex, 0, node)
        } else {
          // Target doesn't exist, append
          this.phases.push(node)
        }
        this.phaseMap.set(autoName, node)
        this.invalidateCache()
      }

      return autoName
    }

    // If after constraint, create/use a phase that comes after it
    if (afterArr.length > 0) {
      const target = afterArr[0]
      const autoName = `after:${target}`

      if (!this.phaseMap.has(autoName)) {
        const node: PhaseNode = { name: autoName, isAutoGenerated: true }
        const targetIndex = this.getPhaseIndex(target)
        if (targetIndex !== -1) {
          this.phases.splice(targetIndex + 1, 0, node)
        } else {
          this.phases.push(node)
        }
        this.phaseMap.set(autoName, node)
        this.invalidateCache()
      }

      return autoName
    }

    // No constraints - default to 'update'
    return 'update'
  }

  // Internal --------------------------------

  private invalidateCache(): void {
    this.orderedNamesCache = null
  }
}
